#include <opencv2/opencv.hpp>
#include <vector>

// 假设contours是已经找到的轮廓，test_point是需要测试的点
double result = pointPolygonTest(contours[i], test_point, false);

// 根据返回值判断点的位置
if (result > 0) {
    // 点在轮廓内部
} else if (result == 0) {
    // 点在轮廓上
} else {
    // 点在轮廓外部
}
-----------------------------------------------------------

std::vector<std::vector<cv::Point>> contours;
// 假设你已经有了轮廓
for (size_t i = 0; i < contours.size(); ++i) {
    const std::vector<cv::Point>& contour = contours[i];
    for (size_t j = 0; j < contour.size(); ++j) {
        // 获取当前点和下一个点
        cv::Point pt1 = contour[j];
        cv::Point pt2 = (j + 1) % contour.size() == 0 ? contour[0] : contour[j + 1];
        // 这里你可以使用pt1和pt2来表示一条边
    }
}
===============================
#include <opencv2/opencv.hpp>
#include <vector>

using namespace cv;
using namespace std;

int main() {
    // 创建一个空白画布，尺寸和类型根据需要进行调整
    Mat image = Mat::zeros(500, 500, CV_8UC3);

    // 定义点集，这里需要您提供具体的点坐标
    vector<Point> points = {
        {10, 10}, {100, 10}, {100, 100}, {10, 100}, // 假设的L型结构
        {200, 200}, {300, 200}, {300, 300}, {200, 300} // 另一个L型结构
    };

    // 定义轮廓的颜色和线宽
    Scalar contourColor(0, 255, 0); // 绿色
    int thickness = 2;

    // 使用polylines函数绘制轮廓
    polylines(image, points, false, contourColor, thickness);

    // 显示图像
    namedWindow("Contour", WINDOW_AUTOSIZE);
    imshow("Contour", image);

    // 等待按键，然后退出
    waitKey(0);
    return 0;
}










